<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>VIP Party Bouncer üé≠</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            overflow: hidden;
            position: relative;
        }

        .game-container {
            max-width: 500px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 20px;
            z-index: 10;
        }

        .header h1 {
            font-size: 2rem;
            text-shadow: 2px 2px 8px rgba(0,0,0,0.3);
            margin-bottom: 10px;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            gap: 20px;
            margin-bottom: 15px;
        }

        .stat-item {
            background: rgba(255,255,255,0.2);
            backdrop-filter: blur(10px);
            padding: 10px 20px;
            border-radius: 15px;
            flex: 1;
            text-align: center;
        }

        .stat-label {
            font-size: 0.8rem;
            opacity: 0.9;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            margin-top: 5px;
        }

        .lives {
            font-size: 1.5rem;
        }

        .timer-container {
            height: 8px;
            background: rgba(255,255,255,0.2);
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 30px;
        }

        .timer-bar {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #feca57);
            border-radius: 10px;
            transition: width linear 7s;
            box-shadow: 0 0 10px rgba(254, 202, 87, 0.6);
        }

        .card-stack {
            flex: 1;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 30px;
        }

        .guest-card {
            position: absolute;
            width: 90%;
            max-width: 350px;
            height: 450px;
            background: white;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            padding: 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            cursor: grab;
            user-select: none;
            transition: transform 0.3s ease;
            touch-action: none;
        }

        .guest-card.dragging {
            cursor: grabbing;
        }

        .guest-card.swipe-right {
            animation: swipeRight 0.5s forwards;
        }

        .guest-card.swipe-left {
            animation: swipeLeft 0.5s forwards;
        }

        .guest-card.swipe-up {
            animation: swipeUp 0.5s forwards;
        }

        @keyframes swipeRight {
            to {
                transform: translateX(200%) rotate(30deg);
                opacity: 0;
            }
        }

        @keyframes swipeLeft {
            to {
                transform: translateX(-200%) rotate(-30deg);
                opacity: 0;
            }
        }

        @keyframes swipeUp {
            to {
                transform: translateY(-200%);
                opacity: 0;
            }
        }

        .guest-emoji {
            font-size: 6rem;
            margin-bottom: 20px;
        }

        .guest-description {
            font-size: 1.3rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 15px;
        }

        .guest-hint {
            font-size: 0.9rem;
            color: #666;
            font-style: italic;
        }

        .swipe-indicators {
            display: flex;
            justify-content: space-around;
            gap: 20px;
            margin-top: auto;
            padding-bottom: 20px;
        }

        .indicator {
            flex: 1;
            padding: 15px;
            border-radius: 15px;
            text-align: center;
            font-weight: bold;
            font-size: 1rem;
        }

        .indicator-left {
            background: linear-gradient(135deg, #ff6b6b, #ee5a6f);
            color: white;
        }

        .indicator-right {
            background: linear-gradient(135deg, #51cf66, #37b24d);
            color: white;
        }

        .game-over-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .game-over-screen.active {
            display: flex;
        }

        .game-over-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            max-width: 400px;
            width: 90%;
        }

        .game-over-content h2 {
            font-size: 2.5rem;
            margin-bottom: 20px;
            color: #667eea;
        }

        .final-score {
            font-size: 3rem;
            font-weight: bold;
            color: #764ba2;
            margin-bottom: 20px;
        }

        .name-input {
            width: 100%;
            padding: 15px;
            font-size: 1.1rem;
            border: 2px solid #667eea;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
        }

        .button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.1rem;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            width: 100%;
            margin-top: 10px;
            transition: transform 0.2s;
        }

        .button:hover {
            transform: scale(1.05);
        }

        .button:active {
            transform: scale(0.95);
        }

        .start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .start-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            max-width: 400px;
            width: 90%;
        }

        .start-content h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            color: #667eea;
        }

        .start-content .subtitle {
            font-size: 1.1rem;
            color: #666;
            margin-bottom: 30px;
        }

        .instructions {
            text-align: left;
            margin-bottom: 30px;
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
        }

        .instructions p {
            margin-bottom: 10px;
            font-size: 0.95rem;
        }

        .instructions strong {
            color: #667eea;
        }

        .feedback {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            font-weight: bold;
            opacity: 0;
            pointer-events: none;
            z-index: 999;
            text-shadow: 2px 2px 8px rgba(0,0,0,0.3);
        }

        .feedback.show {
            animation: feedbackPop 0.6s forwards;
        }

        @keyframes feedbackPop {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
        }
    </style>
</head>
<body>
    <div class="start-screen" id="roleScreen">
        <div class="start-content">
            <h1>üé≠ VIP Party Bouncer</h1>
            <p class="subtitle">Selecciona tu perfil</p>
            <button class="button" onclick="game.selectRole('general')" style="margin-bottom: 10px;">No se nada soy turista üòá</button>
            <div style="font-size: 0.8rem; margin-bottom: 20px; color: #666;">(Correos, Webs, Wifi...)</div>
            <button class="button" onclick="game.selectRole('dev')" style="background: linear-gradient(135deg, #11998e, #38ef7d);">Soy un super Dev üë®‚Äçüíª</button>
            <div style="font-size: 0.8rem; color: #666;">(OWASP, AWS, C√≥digo...)</div>
        </div>
    </div>

    <div class="start-screen" id="startScreen" style="display: none;">
        <div class="start-content">
            <h1 id="startTitle">üé≠ Instrucciones</h1>
            <p class="subtitle">¬°Protege la fiesta de las amenazas!</p>
            <div class="instructions">
                <p><strong>üëâ Desliza a la Derecha:</strong> ACEPTAR (Seguro / Buenas Pr√°cticas)</p>
                <p><strong>üëà Desliza a la Izquierda:</strong> RECHAZAR (Vulnerabilidad / Peligro)</p>
                <p><strong>‚è±Ô∏è Temporizador:</strong> ¬°Decide r√°pido!</p>
                <p><strong>‚ù§Ô∏è Vidas:</strong> Solo tienes 3 oportunidades.</p>
            </div>
            <button class="button" onclick="game.startGame()">¬°A Jugar!</button>
        </div>
    </div>

    <div class="game-container" id="gameContainer" style="display: none;">
        <div class="header">
            <h1>üé≠ VIP Party Bouncer</h1>
            <div class="stats">
                <div class="stat-item">
                    <div class="stat-label">Puntuaci√≥n</div>
                    <div class="stat-value" id="scoreDisplay">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Vidas</div>
                    <div class="stat-value lives" id="livesDisplay">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
                </div>
            </div>
        </div>

        <div class="timer-container">
            <div class="timer-bar" id="timerBar"></div>
        </div>

        <div class="card-stack" id="cardStack">
            <!-- Cards will be dynamically inserted here -->
        </div>
    </div>

    <div class="game-over-screen" id="gameOverScreen">
        <div class="game-over-content">
            <h2>¬°Juego Terminado! üéÆ</h2>
            <div class="final-score" id="finalScore">0</div>
            <input type="text" class="name-input" id="playerName" placeholder="Ingresa tu nombre" maxlength="20">
            <input type="email" class="name-input" id="playerEmail" placeholder="Ingresa tu email" maxlength="50">
            <button class="button" onclick="game.submitScore()">Enviar Puntuaci√≥n</button>
            <button class="button" onclick="game.restartGame()">Jugar de Nuevo</button>
        </div>
    </div>

    <div class="feedback" id="feedback"></div>

    <script>
        const GUEST_DATA_GENERAL = [
            // SAFE ENTRIES (Swiping Right allows them in)
            { emoji: "üìß", description: "Correo de RRHH sobre beneficios del a√±o", safe: true, hint: "Dominio interno verificado" },
            { emoji: "üîí", description: "Web pidiendo cambio de clave (https)", safe: true, hint: "Certificado de seguridad v√°lido" },
            { emoji: "üë®‚Äçüíª", description: "Soporte TI conect√°ndose con ticket aprobado", safe: true, hint: "Solicitud iniciada por ti" },
            { emoji: "üì±", description: "Notificaci√≥n de acceso 2FA en tu m√≥vil", safe: true, hint: "T√∫ est√°s intentando entrar" },
            { emoji: "üíæ", description: "Copia de seguridad en servidor cifrado", safe: true, hint: "Protocolo de respaldo seguro" },
            { emoji: "üìÑ", description: "Adjunto PDF de proveedor conocido", safe: true, hint: "Analizado por antivirus" },
            { emoji: "üåê", description: "Navegando en intranet corporativa (VPN)", safe: true, hint: "Conexi√≥n segura establecida" },
            { emoji: "üîÑ", description: "Actualizaci√≥n autom√°tica de Windows", safe: true, hint: "Parche de seguridad oficial" },
            { emoji: "üë•", description: "Reuni√≥n de Teams con enlace de la empresa", safe: true, hint: "Plataforma oficial" },
            { emoji: "üîë", description: "Usando gestor de contrase√±as corporativo", safe: true, hint: "Almacenamiento seguro" },
            { emoji: "üõ°Ô∏è", description: "Antivirus bloqueando pop-up sospechoso", safe: true, hint: "Herramienta funcionando bien" },
            { emoji: "üì§", description: "Enviando datos sensibles por canal cifrado", safe: true, hint: "Cumple pol√≠tica de DLP" },
            
            // THREATS / VULNERABILITIES (Swiping Left rejects/reports them)
            { emoji: "üéÅ", description: "¬°Ganaste un iPhone! Haz clic aqu√≠", safe: false, hint: "Phishing cl√°sico" },
            { emoji: "üìé", description: "Factura_Urgente.exe en un correo", safe: false, hint: "Extensi√≥n de archivo peligrosa" },
            { emoji: "üìû", description: "Llamada del 'CEO' pidiendo claves ya", safe: false, hint: "Ingenier√≠a social (Vishing)" },
            { emoji: "üîå", description: "USB encontrado en el estacionamiento", safe: false, hint: "Posible malware (Baiting)" },
            { emoji: "üì∂", description: "WiFi 'Gratis_Aeropuerto' sin contrase√±a", safe: false, hint: "Red no segura (Sniffing)" },
            { emoji: "üìù", description: "Pegar contrase√±a en un Post-it en el monitor", safe: false, hint: "Mala higiene de seguridad" },
            { emoji: "üè¶", description: "Web del banco con errores de ortograf√≠a", safe: false, hint: "Sitio web clonado" },
            { emoji: "üîÑ", description: "Ignorar actualizaci√≥n de seguridad por 6 meses", safe: false, hint: "Sistema vulnerable sin parches" },
            { emoji: "üë§", description: "Compartir tu usuario con el pasante", safe: false, hint: "Cuentas personales e intransferibles" },
            { emoji: "üåê", description: "Web que pide datos sin candadito (http)", safe: false, hint: "Comunicaci√≥n no cifrada (Man-in-the-Middle)" },
            { emoji: "üì±", description: "Instalar App 'gratis' fuera de la tienda oficial", safe: false, hint: "Software no autorizado (Sideloading)" },
            { emoji: "üôä", description: "Hablar de secretos de la empresa en el ascensor", safe: false, hint: "Fuga de informaci√≥n" },
            { emoji: "üì©", description: "Correo de 'Soporte' pidiendo tu contrase√±a", safe: false, hint: "Soporte real nunca pide tu clave" },
            { emoji: "üíª", description: "Dejar la laptop desbloqueada en la cafeter√≠a", safe: false, hint: "Acceso f√≠sico no autorizado" }
        ];

        const GUEST_DATA_DEV = [
             // SAFE (Swipe Right)
            { emoji: "üîê", description: "Commit firmado con clave GPG", safe: true, hint: "Integridad de c√≥digo verificada" },
            { emoji: "ü§ñ", description: "Dependabot: PR de parche de seguridad", safe: true, hint: "Gesti√≥n proactiva de dependencias" },
            { emoji: "‚òÅÔ∏è", description: "S3 Bucket: Public Access Blocked", safe: true, hint: "Configuraci√≥n correcta de privacidad" },
            { emoji: "üíâ", description: "Query SQL usando Prepared Statements", safe: true, hint: "Prevenci√≥n de SQL Injection" },
            { emoji: "ü§ê", description: "API Key le√≠da desde Vault/Secrets Manager", safe: true, hint: "Gesti√≥n segura de secretos" },
            { emoji: "üê≥", description: "Imagen Docker 'distroless' (sin shell)", safe: true, hint: "Reducci√≥n de superficie de ataque" },
            { emoji: "üëÄ", description: "Merge Request aprobado por 2 reviewers", safe: true, hint: "Revisi√≥n de c√≥digo obligatoria" },
            { emoji: "üîí", description: "Terraform State cifrado en backend remoto", safe: true, hint: "Protecci√≥n de infraestructura (IaC)" },
            { emoji: "üõ°Ô∏è", description: "WAF bloqueando tr√°fico malicioso (XSS)", safe: true, hint: "Seguridad perimetral activa" },
            { emoji: "üé´", description: "JWT firmado y con expiraci√≥n de 15 min", safe: true, hint: "Gesti√≥n de sesiones robusta" },
            { emoji: "üìù", description: "Logs sanitizados (Sin PII/Datos personales)", safe: true, hint: "Privacidad por dise√±o" },
            { emoji: "üîë", description: "MFA habilitado para la cuenta AWS Root", safe: true, hint: "Protecci√≥n de identidad cr√≠tica" },

            // UNSAFE / VULNERABILITIES (Swipe Left)
            { emoji: "üîë", description: "AWS Access Key hardcodeada en c√≥digo", safe: false, hint: "Secretos expuestos (Credential Leak)" },
            { emoji: "ü™£", description: "S3 Bucket p√∫blico con datos de usuarios", safe: false, hint: "Exposici√≥n de datos (Misconfiguration)" },
            { emoji: "üîì", description: "chmod 777 -R en carpeta del servidor", safe: false, hint: "Permisos excesivos (Broken Access Control)" },
            { emoji: "üôà", description: "Desactivar validaci√≥n SSL en producci√≥n", safe: false, hint: "Fallo en integridad (Man-In-The-Middle)" },
            { emoji: "üìú", description: "Commit incluyendo archivo .env", safe: false, hint: "Exposici√≥n de secretos en git" },
            { emoji: "üëë", description: "Conexi√≥n a BD con usuario 'sa' o 'root'", safe: false, hint: "Violaci√≥n de principio de menor privilegio" },
            { emoji: "üì¶", description: "Librer√≠a open-source abandonada hace 5 a√±os", safe: false, hint: "Componente vulnerable y desactualizado" },
            { emoji: "üí•", description: "dangerouslySetInnerHTML(input_usuario)", safe: false, hint: "Cross-Site Scripting (XSS Dom-based)" },
            { emoji: "üåê", description: "Puerto SSH (22) abierto a 0.0.0.0/0", safe: false, hint: "Exposici√≥n de gesti√≥n remota" },
            { emoji: "üêõ", description: "Error 500 mostrando Stack Trace al usuario", safe: false, hint: "Fuga de informaci√≥n t√©cnica" },
            { emoji: "üìõ", description: "Guardar passwords en texto plano o MD5", safe: false, hint: "Fallo criptogr√°fico cr√≠tico" },
            { emoji: "üö™", description: "API: DELETE /user/5 sin verificar auth", safe: false, hint: "Broken Access Control (BOLA/IDOR)" }
        ];

        class CardManager {
            constructor() {
                this.cards = [];
                this.currentCardIndex = 0;
            }

            reset() {
                this.cards = [];
                this.currentCardIndex = 0;
            }

            createCard(guestData) {
                const card = document.createElement('div');
                card.className = 'guest-card';
                card.innerHTML = `
                    <div class="guest-emoji">${guestData.emoji}</div>
                    <div class="guest-description">${guestData.description}</div>
                    <div class="guest-hint">${guestData.hint}</div>
                `;
                card.dataset.safe = guestData.safe;
                return card;
            }

            shuffleGuests(mode) {
                const data = mode === 'dev' ? GUEST_DATA_DEV : GUEST_DATA_GENERAL;
                return [...data].sort(() => Math.random() - 0.5);
            }

            initializeCards(container, mode) {
                const shuffled = this.shuffleGuests(mode);
                this.cards = shuffled.map(guest => this.createCard(guest));
                this.currentCardIndex = 0;
                
                container.innerHTML = '';
                const numInitialCards = Math.min(3, this.cards.length);
                for (let i = 0; i < numInitialCards; i++) {
                    container.appendChild(this.cards[i]);
                    const stackPosition = numInitialCards - 1 - i;
                    this.cards[i].style.transform = `scale(${1 - stackPosition * 0.05}) translateY(${stackPosition * 5}px)`;
                    this.cards[i].style.zIndex = 100 + (numInitialCards - 1 - i);
                    this.cards[i].dataset.cardIndex = i;
                }
            }


            getCurrentCard() {
                return this.cards[this.currentCardIndex];
            }

            nextCard(container) {
                this.currentCardIndex++;
                
                if (this.currentCardIndex >= this.cards.length) {
                    return null; 
                }

                const nextIndex = this.currentCardIndex + 2;
                if (nextIndex < this.cards.length) {
                    const newCard = this.cards[nextIndex];
                    container.appendChild(newCard); 
                    newCard.style.transform = `scale(0.9) translateY(10px)`;
                    newCard.dataset.cardIndex = nextIndex;
                }
                
                this.updateCardZIndices(container);

                return this.cards[this.currentCardIndex];
            }

            updateCardZIndices(container) {
                const cardsInDom = Array.from(container.children);
                cardsInDom.forEach((card) => {
                    const cardIdx = parseInt(card.dataset.cardIndex);
                    const offset = cardIdx - this.currentCardIndex;
                    card.style.zIndex = 100 - offset; 
                });
            }

            hasMoreCards() {
                return this.currentCardIndex < this.cards.length - 1;
            }
        }

        class GameState {
            constructor() {
                this.lives = 3;
                this.score = 0;
                this.isActive = false;
                this.timerInterval = null;
            }

            reset() {
                this.lives = 3;
                this.score = 0;
                this.isActive = false;
                this.clearTimer();
            }

            addScore(points) {
                this.score += points;
            }

            loseLife() {
                this.lives--;
                return this.lives <= 0;
            }

            startTimer(callback) {
                this.clearTimer();
                const timerBar = document.getElementById('timerBar');
                timerBar.style.width = '100%';
                timerBar.style.transition = 'none';
                
                setTimeout(() => {
                    timerBar.style.transition = 'width linear 7s';
                    timerBar.style.width = '0%';
                }, 50);

                this.timerInterval = setTimeout(callback, 7000);
            }

            clearTimer() {
                if (this.timerInterval) {
                    clearTimeout(this.timerInterval);
                    this.timerInterval = null;
                }
            }
        }

        class VIPBouncerGame {
            constructor() {
                this.cardManager = new CardManager();
                this.gameState = new GameState();
                this.touchStartX = 0;
                this.touchStartY = 0;
                this.currentCard = null;
                this.isProcessing = false; 
                this.isDragging = false; 
                this.currentRole = 'general'; // Default role
                
                this.cardStack = document.getElementById('cardStack');
                this.bindEvents();
            }

            // ... (bindEvents is unchanged)

            bindEvents() {
                // Touch events for mobile
                this.cardStack.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: false });
                this.cardStack.addEventListener('touchend', (e) => this.handleTouchEnd(e));
                this.cardStack.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });
                
                // Mouse events for desktop/testing
                this.cardStack.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                document.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                document.addEventListener('mousemove', (e) => this.handleMouseMove(e));
            }

            selectRole(role) {
                this.currentRole = role;
                document.getElementById('roleScreen').style.display = 'none';
                document.getElementById('startScreen').style.display = 'flex';
                
                // Update title based on role
                const title = document.getElementById('startTitle');
                if (role === 'dev') {
                    title.textContent = 'üë®‚Äçüíª Modo DevSecOps';
                } else {
                    title.textContent = 'üë§ÔøΩ Modo Turista';
                }
            }

            startGame() {
                document.getElementById('startScreen').style.display = 'none';
                document.getElementById('gameContainer').style.display = 'flex';
                
                this.gameState.reset();
                this.gameState.isActive = true;
                
                this.cardManager.initializeCards(this.cardStack, this.currentRole);
                this.currentCard = this.cardManager.getCurrentCard();
                
                this.updateUI();
                this.startCardTimer();
            }

            handleMouseDown(e) {
                if (this.isProcessing) return;
                if (!this.gameState.isActive) return;

                let touchedCard = e.target;
                while (touchedCard && !touchedCard.classList.contains('guest-card')) {
                    touchedCard = touchedCard.parentElement;
                }
                
                if (!touchedCard || touchedCard !== this.currentCard) return;
                e.preventDefault(); 
                this.touchStartX = e.clientX;
                this.touchStartY = e.clientY;
                this.currentCard.classList.add('dragging');
                this.isDragging = true;
            }

            handleMouseMove(e) {
                if (!this.isDragging || !this.currentCard) return;
                
                const deltaX = e.clientX - this.touchStartX;
                const rotation = deltaX / 10;
                this.currentCard.style.transform = `rotate(${rotation}deg)`;
            }

            handleMouseUp(e) {
                if (!this.isDragging || !this.currentCard) {
                    this.isDragging = false;
                    return;
                }
                
                if (!this.currentCard.classList.contains('dragging')) {
                    this.isDragging = false;
                    return;
                }

                const touchEndX = e.clientX;
                const touchEndY = e.clientY;
                
                const deltaX = touchEndX - this.touchStartX;
                const deltaY = touchEndY - this.touchStartY;
                
                // Reset visual state
                this.currentCard.style.transform = '';
                this.currentCard.classList.remove('dragging');
                this.isDragging = false;

                // Determine swipe direction
                if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 50) {
                    if (deltaX > 0) {
                        this.handleSwipe('right');
                    } else {
                        this.handleSwipe('left');
                    }
                } else if (deltaY < -50) {
                    this.handleSwipe('up');
                }
            }

            handleTouchStart(e) {
                if (this.isProcessing) return;
                if (!this.gameState.isActive) return;

                // Find which card was touched by checking parent elements
                let touchedCard = e.target;
                while (touchedCard && !touchedCard.classList.contains('guest-card')) {
                    touchedCard = touchedCard.parentElement;
                }
                
                if (!touchedCard || touchedCard !== this.currentCard) return;
                e.preventDefault(); // Prevent scrolling
                this.touchStartX = e.touches[0].clientX;
                this.touchStartY = e.touches[0].clientY;
                this.currentCard.classList.add('dragging');
            }

            handleTouchEnd(e) {
                if (!this.currentCard) return;
                if (!this.currentCard.classList.contains('dragging')) return;

                const touchEndX = e.changedTouches[0].clientX;
                const touchEndY = e.changedTouches[0].clientY;
                
                const deltaX = touchEndX - this.touchStartX;
                const deltaY = touchEndY - this.touchStartY;
                
                this.currentCard.classList.remove('dragging');

                // Determine swipe direction
                if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 50) {
                    if (deltaX > 0) {
                        this.handleSwipe('right');
                    } else {
                        this.handleSwipe('left');
                    }
                } else if (deltaY < -50) {
                    this.handleSwipe('up');
                }
            }

            handleSwipe(direction) {
                if (!this.gameState.isActive || this.isProcessing) return;

                this.isProcessing = true; // Block new input
                this.gameState.clearTimer();
                const isSafe = this.currentCard.dataset.safe === 'true';

                let correct = false;
                if (direction === 'right' && isSafe) {
                    correct = true;
                } else if (direction === 'left' && !isSafe) {
                    correct = true;
                } else if (direction === 'up') {
                    correct = false; // Auto-fail
                }

                // Animate card
                this.currentCard.classList.add(`swipe-${direction}`);

                // Show feedback
                this.showFeedback(correct);

                // Update game state
                if (correct) {
                    this.gameState.addScore(100);
                } else {
                    const gameOver = this.gameState.loseLife();
                    if (gameOver) {
                        setTimeout(() => this.endGame(), 500);
                        return;
                    }
                }

                this.updateUI();

                // Next card
                setTimeout(() => {
                    const cardStack = document.getElementById('cardStack');
                    this.currentCard.remove();
                    
                    const nextCard = this.cardManager.nextCard(cardStack);
                    
                    if (nextCard) {
                        this.currentCard = nextCard;
                        this.isProcessing = false; // Allow new input
                        this.startCardTimer();
                    } else {
                        // All cards done - end game
                        this.isProcessing = false;
                        setTimeout(() => this.endGame(), 500);
                    }
                }, 500);
            }

            startCardTimer() {
                this.gameState.startTimer(() => {
                    // Time's up - auto fail
                    this.handleSwipe('up');
                });
            }

            showFeedback(correct) {
                const feedback = document.getElementById('feedback');
                feedback.textContent = correct ? '‚úÖ ¬°CORRECTO!' : '‚ùå ¬°INCORRECTO!';
                feedback.style.color = correct ? '#51cf66' : '#ff6b6b';
                feedback.classList.add('show');
                
                setTimeout(() => {
                    feedback.classList.remove('show');
                }, 600);
            }

            updateUI() {
                document.getElementById('scoreDisplay').textContent = this.gameState.score;
                const hearts = '‚ù§Ô∏è'.repeat(this.gameState.lives) + 'üñ§'.repeat(3 - this.gameState.lives);
                document.getElementById('livesDisplay').textContent = hearts;
            }

            endGame() {
                this.gameState.isActive = false;
                this.gameState.clearTimer();
                
                document.getElementById('finalScore').textContent = this.gameState.score;
                document.getElementById('gameOverScreen').classList.add('active');
            }

            async submitScore() {
                const playerName = document.getElementById('playerName').value.trim();
                const playerEmail = document.getElementById('playerEmail').value.trim();
                
                if (!playerName) {
                    alert('¬°Por favor ingresa tu nombre!');
                    return;
                }
                
                if (!playerEmail) {
                    alert('¬°Por favor ingresa tu email!');
                    return;
                }

                try {
                    const response = await fetch('/api/score', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            player_name: playerName,
                            email: playerEmail,
                            score: this.gameState.score,
                            timestamp: new Date().toISOString()
                        })
                    });

                    if (response.ok) {
                        alert('¬°Puntuaci√≥n enviada exitosamente! üéâ');
                        this.restartGame();
                    } else {
                        alert('Error al enviar la puntuaci√≥n. Por favor intenta de nuevo.');
                    }
                } catch (error) {
                    console.error('Error submitting score:', error);
                    alert('Error al conectar con el servidor. ¬°Aseg√∫rate de que el backend est√© ejecut√°ndose!');
                }
            }

            restartGame() {
                document.getElementById('gameOverScreen').classList.remove('active');
                document.getElementById('roleScreen').style.display = 'flex'; // Go back to role selection
                document.getElementById('playerName').value = '';
                document.getElementById('playerEmail').value = '';
                this.cardManager.reset();
                this.isProcessing = false;
                this.isDragging = false;
                this.currentCard = null;
                // Game starts after selecting role again
            }
        }

        // Initialize game
        const game = new VIPBouncerGame();
    </script>
</body>
</html>
